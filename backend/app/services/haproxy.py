import asyncio
import logging
import os
import subprocess

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.config import settings
from app.models.tunnel import Tunnel
from app.models.system_flag import SystemFlag

logger = logging.getLogger(__name__)

HAPROXY_RELOAD_FLAG = "haproxy_reload_needed"
DAEMON_INTERVAL_SECONDS = 5


class HAProxyService:
    """
    Generates HAProxy config snippets to be included in the existing
    HAProxy configuration on homeaccess.site.

    Two files are generated:
    - homevpn-backends.cfg: backend blocks for each active tunnel
    - homevpn-subdomains.map: subdomain-to-backend map file

    The existing HAProxy config should include:
        # In the frontend section:
        http-request set-var(req.subdomain) req.hdr(host),lower,regsub(\.domoteus\.com$,,)
        use_backend %[var(req.subdomain),map(/etc/haproxy/homevpn-subdomains.map)]

        # At the end:
        .include /etc/haproxy/homevpn-backends.cfg
    """

    def __init__(self):
        self.backends_path = settings.haproxy_backends_path
        self.map_path = settings.haproxy_map_path

    async def regenerate_config(self, db: AsyncSession) -> None:
        result = await db.execute(
            select(Tunnel).where(Tunnel.is_active == True)  # noqa: E712
        )
        tunnels = result.scalars().all()

        backends_lines = [
            "# Auto-generated by HomeVPN API. Do not edit manually.\n"
        ]
        map_entries = []

        for tunnel in tunnels:
            backend_name = f"bk_hvpn_{tunnel.subdomain}"
            backends_lines.append(f"backend {backend_name}")
            target_ip = tunnel.device_ip if tunnel.use_device_ip else tunnel.vpn_ip
            backends_lines.append(
                f"    server srv1 {target_ip}:{tunnel.target_port} check inter 10s fall 3 rise 2"
            )
            backends_lines.append("")
            map_entries.append(f"{tunnel.subdomain} {backend_name}")

        # Write backends config file
        os.makedirs(os.path.dirname(self.backends_path), exist_ok=True)
        with open(self.backends_path, "w") as f:
            f.write("\n".join(backends_lines))

        # Write map file
        os.makedirs(os.path.dirname(self.map_path), exist_ok=True)
        with open(self.map_path, "w") as f:
            f.write("# Auto-generated by HomeVPN API. Do not edit manually.\n")
            if map_entries:
                f.write("\n".join(map_entries) + "\n")

        self._reload()

    def _reload(self) -> None:
        """Reload HAProxy via sudo systemctl (allowed via sudoers.d/homevpn)."""
        try:
            subprocess.run(
                ["sudo", "systemctl", "reload", "haproxy"],
                check=True,
                capture_output=True,
            )
            logger.info("HAProxy reloaded successfully")
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            logger.error("HAProxy reload failed: %s", e)


haproxy_service = HAProxyService()


async def request_haproxy_reload() -> None:
    """Set the haproxy_reload_needed flag in the database.

    Uses a dedicated session to avoid affecting the caller's transaction.
    """
    from app.database import async_session

    try:
        async with async_session() as session:
            await session.execute(
                update(SystemFlag)
                .where(SystemFlag.key == HAPROXY_RELOAD_FLAG)
                .values(value=True)
            )
            await session.commit()
    except Exception:
        logger.exception("Failed to set haproxy reload flag")


async def haproxy_daemon_loop() -> None:
    """Background loop that checks the reload flag every 5 seconds.

    When the flag is set:
    1. Clear the flag first (so concurrent changes re-arm it)
    2. Regenerate HAProxy config from current DB state
    3. Reload HAProxy
    """
    from app.database import async_session

    logger.info("HAProxy daemon started (interval=%ds)", DAEMON_INTERVAL_SECONDS)

    while True:
        try:
            await asyncio.sleep(DAEMON_INTERVAL_SECONDS)

            async with async_session() as session:
                result = await session.execute(
                    select(SystemFlag.value).where(
                        SystemFlag.key == HAPROXY_RELOAD_FLAG
                    )
                )
                flag_value = result.scalar_one_or_none()

                if not flag_value:
                    continue

                # Clear flag BEFORE regenerating â€” any new change during
                # regen will re-arm the flag for the next cycle
                await session.execute(
                    update(SystemFlag)
                    .where(SystemFlag.key == HAPROXY_RELOAD_FLAG)
                    .values(value=False)
                )
                await session.commit()

            # Regenerate with a fresh session
            async with async_session() as regen_session:
                await haproxy_service.regenerate_config(regen_session)

            logger.info("HAProxy config regenerated by daemon")

        except asyncio.CancelledError:
            logger.info("HAProxy daemon stopped")
            break
        except Exception:
            logger.exception("HAProxy daemon error (will retry)")
